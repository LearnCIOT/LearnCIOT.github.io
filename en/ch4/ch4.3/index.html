<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>

<meta property="og:title" content="4.3. Time Series Data Clustering"/>
<meta property="og:description" content="We introduce advanced data grouping analysis. We first present two time-series feature extraction methods, Fourier transform and wavelet transform, and briefly explain the similarities and differences between the two transform methods. We introduce two different time series comparison methods, Euclidean distance and dynamic time warping (DTW), and apply existing clustering algorithms accordingly. We then discuss data clustering with different temporal resolutions, as well as their representation and potential applications in the real world."/>
<meta property="og:image" content="https://learnciot.github.io/images/thumbnail.jpg"/>
<meta property="og:url" content="/en/ch4/ch4.3/"/>
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="627" />
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.104.3">
    <meta name="generator" content="Relearn 5.3.3+tip">
    <meta name="description" content="We introduce advanced data grouping analysis. We first present two time-series feature extraction methods, Fourier transform and wavelet transform, and briefly explain the similarities and differences between the two transform methods. We introduce two different time series comparison methods, Euclidean distance and dynamic time warping (DTW), and apply existing clustering algorithms accordingly. We then discuss data clustering with different temporal resolutions, as well as their representation and potential applications in the real world.">
    <meta name="author" content="Ling-Jyh Chen">
    <title>4.3. Time Series Data Clustering :: Tutorial for CIoT Open Data Applications</title>
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="/css/fontawesome-all.min.css?1701306708" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fontawesome-all.min.css?1701306708" rel="stylesheet"></noscript>
    <link href="/css/featherlight.min.css?1701306708" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/featherlight.min.css?1701306708" rel="stylesheet"></noscript>
    <link href="/css/auto-complete.css?1701306708" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/auto-complete.css?1701306708" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar.min.css?1701306708" rel="stylesheet">
    <link href="/css/nucleus.css?1701306708" rel="stylesheet">
    <link href="/css/fonts.css?1701306708" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/css/fonts.css?1701306708" rel="stylesheet"></noscript>
    <link href="/css/theme.css?1701306708" rel="stylesheet">
    <link href="/css/theme-relearn-light.css?1701306708" rel="stylesheet" id="variant-style">
    <link href="/css/ie.css?1701306708" rel="stylesheet">
    <link href="/css/variant.css?1701306708" rel="stylesheet">
    <link href="/css/print.css?1701306708" rel="stylesheet" media="print">
    <script src="/js/variant.js?1701306708"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="/en/index.json";
      var root_url="/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/LearnCIOT.github.io/';
      window.variants && variants.init( [ 'relearn-light' ] );
    </script>
    <script src="/js/jquery.min.js?1701306708" defer></script>
<meta property="fb:app_id" content="601826851395774" />
  </head>
  <body class="default-animation" data-url="/en/ch4/ch4.3/">




<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v14.0" nonce="hWjBXHAv"></script>

    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="/en/ch5/" title="5. Spatial Data Analysis"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="/en/ch4/ch4.2/" title="4.2. Time Series Data Forecast"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit' href="https://github.com/LearnCIOT/LearnCIOT.github.io/tree/main/content/ch4/ch4.3/index.en.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="3" /><a itemprop="item" href="/en/"><span itemprop="name">Learning Civil IoT Taiwan Open Data and Its Applications</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="/en/ch4/"><span itemprop="name">4. Time Series Data Analysis</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="/en/ch4/ch4.3/" aria-disabled="true"><span itemprop="name">4.3. Time Series Data Clustering</span></a></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#goal">Goal</a></li>
    <li><a href="#package-installation-and-importing">Package Installation and Importing</a></li>
    <li><a href="#data-access-and-preprocessing">Data Access and Preprocessing</a></li>
    <li><a href="#data-clustering">Data Clustering</a>
      <ul>
        <li><a href="#fast-fourier-transform">Fast Fourier Transform</a></li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>

      <main id="body-inner" class="highlightable ">
        <div class="flex-block-wrapper">
          <div id="head-tags"><div class="tags">
  <a class="level-link" href="/en/levels/advanced">
  <b>
	&starf;&starf;&starf;&starf;&starf;
  </b>
  </a>
  <a class="tag-link" href="/en/tags/air">Air</a>
  <a class="tag-link" href="/en/tags/python">Python</a>
</div>

          </div>


  
  
  

  <section class="social-share">
    <ul class="share-icons">
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?hashtags=codingnconcepts&amp;url=https%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f&amp;text=4.3.%20Time%20Series%20Data%20Clustering" target="_blank" rel="noopener" aria-label="Share on Twitter" class="share-btn twitter">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="26px" viewBox="0 0 31 26" version="1.1">
<g id="surface1">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(11.372549%,60.784314%,94.117647%);fill-opacity:1;" d="M 27.742188 6.535156 C 27.761719 6.8125 27.761719 7.089844 27.761719 7.371094 C 27.761719 15.875 21.414062 25.683594 9.800781 25.683594 L 9.800781 25.675781 C 6.371094 25.683594 3.011719 24.679688 0.125 22.792969 C 0.625 22.851562 1.125 22.882812 1.628906 22.886719 C 4.46875 22.886719 7.230469 21.914062 9.46875 20.125 C 6.765625 20.070312 4.398438 18.277344 3.570312 15.65625 C 4.515625 15.839844 5.492188 15.800781 6.421875 15.542969 C 3.476562 14.9375 1.355469 12.300781 1.355469 9.234375 L 1.355469 9.152344 C 2.234375 9.652344 3.214844 9.929688 4.222656 9.960938 C 1.449219 8.070312 0.59375 4.304688 2.265625 1.363281 C 5.472656 5.386719 10.203125 7.832031 15.277344 8.089844 C 14.769531 5.855469 15.464844 3.511719 17.105469 1.941406 C 19.644531 -0.496094 23.644531 -0.371094 26.035156 2.21875 C 27.449219 1.933594 28.804688 1.40625 30.042969 0.65625 C 29.574219 2.144531 28.585938 3.410156 27.269531 4.214844 C 28.519531 4.066406 29.742188 3.722656 30.894531 3.203125 C 30.046875 4.496094 28.980469 5.625 27.742188 6.535156 Z M 27.742188 6.535156 "/>
</g>
</svg>

          <p>Twitter</p>
          </a>
      </li>
      

      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f" target="_blank" rel="noopener" aria-label="Share on Facebook" class="share-btn facebook">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
<defs>
<linearGradient id="linear0" gradientUnits="userSpaceOnUse" x1="-277.375" y1="406.6018" x2="-277.375" y2="407.5726" gradientTransform="matrix(32,0,0,-31.82224,8892.0008,12969.8672)">
<stop offset="0" style="stop-color:rgb(0%,38.431373%,87.843137%);stop-opacity:1;"/>
<stop offset="1" style="stop-color:rgb(9.803922%,68.627451%,100%);stop-opacity:1;"/>
</linearGradient>
</defs>
<g id="surface1">
<path style=" stroke:none;fill-rule:nonzero;fill:url(#linear0);" d="M 13.359375 31.839844 C 5.761719 30.480469 0 23.921875 0 16 C 0 7.199219 7.199219 0 16 0 C 24.800781 0 32 7.199219 32 16 C 32 23.921875 26.238281 30.480469 18.640625 31.839844 L 17.761719 31.121094 L 14.238281 31.121094 Z M 13.359375 31.839844 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 22.238281 20.480469 L 22.960938 16 L 18.71875 16 L 18.71875 12.878906 C 18.71875 11.601562 19.199219 10.640625 21.121094 10.640625 L 23.199219 10.640625 L 23.199219 6.558594 C 22.078125 6.398438 20.800781 6.238281 19.679688 6.238281 C 16 6.238281 13.441406 8.480469 13.441406 12.480469 L 13.441406 16 L 9.441406 16 L 9.441406 20.480469 L 13.441406 20.480469 L 13.441406 31.761719 C 14.320312 31.921875 15.199219 32 16.078125 32 C 16.960938 32 17.839844 31.921875 18.71875 31.761719 L 18.71875 20.480469 Z M 22.238281 20.480469 "/>
</g>
</svg>

          <p>Facebook</p>
          </a>
      </li>
      

      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f&amp;source=https%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f&amp;title=4.3.%20Time%20Series%20Data%20Clustering&amp;summary=4.3.%20Time%20Series%20Data%20Clustering" target="_blank" rel="noopener" aria-label="Share on LinkedIn" class="share-btn linkedin">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
<g id="surface1">
<path style=" stroke:none;fill-rule:evenodd;fill:rgb(0%,49.411765%,73.333333%);fill-opacity:1;" d="M 16 32 C 24.835938 32 32 24.835938 32 16 C 32 7.164062 24.835938 0 16 0 C 7.164062 0 0 7.164062 0 16 C 0 24.835938 7.164062 32 16 32 Z M 16 32 "/>
<path style=" stroke:none;fill-rule:evenodd;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 26.222656 25.332031 L 22.203125 25.332031 L 22.203125 18.488281 C 22.203125 16.613281 21.492188 15.566406 20.007812 15.566406 C 18.390625 15.566406 17.546875 16.65625 17.546875 18.488281 L 17.546875 25.332031 L 13.675781 25.332031 L 13.675781 12.296875 L 17.546875 12.296875 L 17.546875 14.050781 C 17.546875 14.050781 18.710938 11.898438 21.476562 11.898438 C 24.242188 11.898438 26.222656 13.585938 26.222656 17.078125 Z M 9.054688 10.589844 C 7.734375 10.589844 6.667969 9.511719 6.667969 8.183594 C 6.667969 6.855469 7.734375 5.777344 9.054688 5.777344 C 10.375 5.777344 11.441406 6.855469 11.441406 8.183594 C 11.441406 9.511719 10.375 10.589844 9.054688 10.589844 Z M 7.054688 25.332031 L 11.09375 25.332031 L 11.09375 12.296875 L 7.054688 12.296875 Z M 7.054688 25.332031 "/>
</g>
</svg>

            <p>LinkedIn</p>
          </a>
      </li>
      

      
      
      <li>
        <a href="whatsapp://send?text=4.3.%20Time%20Series%20Data%20Clustering%2c%20by%20Tutorial%20for%20CIoT%20Open%20Data%20Applications%0aWe%20introduce%20advanced%20data%20grouping%20analysis.%20We%20first%20present%20two%20time-series%20feature%20extraction%20methods%2c%20Fourier%20transform%20and%20wavelet%20transform%2c%20and%20briefly%20explain%20the%20similarities%20and%20differences%20between%20the%20two%20transform%20methods.%20We%20introduce%20two%20different%20time%20series%20comparison%20methods%2c%20Euclidean%20distance%20and%20dynamic%20time%20warping%20%28DTW%29%2c%20and%20apply%20existing%20clustering%20algorithms%20accordingly.%20We%20then%20discuss%20data%20clustering%20with%20different%20temporal%20resolutions%2c%20as%20well%20as%20their%20representation%20and%20potential%20applications%20in%20the%20real%20world.%0a%0ahttps%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f%0a" target="_blank" class="share-btn whatsapp">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
<defs>
<image id="image5" width="588" height="590" xlink:href="data:image/png;base64,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"/>
</defs>
<g id="surface2">
<use xlink:href="#image5" transform="matrix(0.054145,0,0,0.054145,0.054145,0)"/>
<path style=" stroke:none;fill-rule:evenodd;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 24.355469 7.726562 C 22.222656 5.585938 19.378906 4.410156 16.355469 4.40625 C 10.117188 4.40625 5.042969 9.484375 5.042969 15.71875 C 5.039062 17.714844 5.5625 19.660156 6.550781 21.375 L 4.945312 27.238281 L 10.945312 25.664062 C 12.597656 26.566406 14.457031 27.039062 16.351562 27.042969 L 16.355469 27.042969 C 22.589844 27.042969 27.664062 21.964844 27.667969 15.730469 C 27.667969 12.707031 26.492188 9.863281 24.355469 7.726562 Z M 16.355469 25.132812 L 16.351562 25.132812 C 14.664062 25.128906 13.007812 24.675781 11.566406 23.820312 L 11.222656 23.617188 L 7.664062 24.550781 L 8.613281 21.082031 L 8.390625 20.722656 C 7.449219 19.226562 6.949219 17.496094 6.953125 15.71875 C 6.953125 10.535156 11.171875 6.320312 16.359375 6.320312 C 18.871094 6.320312 21.230469 7.296875 23.003906 9.074219 C 24.78125 10.851562 25.757812 13.214844 25.757812 15.726562 C 25.753906 20.914062 21.535156 25.132812 16.355469 25.132812 Z M 21.511719 18.089844 C 21.230469 17.945312 19.839844 17.261719 19.582031 17.167969 C 19.320312 17.074219 19.132812 17.027344 18.945312 17.3125 C 18.757812 17.59375 18.214844 18.230469 18.050781 18.417969 C 17.882812 18.609375 17.71875 18.632812 17.4375 18.488281 C 17.152344 18.347656 16.242188 18.050781 15.164062 17.085938 C 14.324219 16.335938 13.757812 15.410156 13.589844 15.128906 C 13.425781 14.84375 13.574219 14.691406 13.714844 14.550781 C 13.84375 14.425781 13.996094 14.222656 14.140625 14.054688 C 14.28125 13.890625 14.328125 13.773438 14.421875 13.585938 C 14.515625 13.394531 14.46875 13.230469 14.398438 13.089844 C 14.328125 12.949219 13.761719 11.554688 13.527344 10.992188 C 13.296875 10.441406 13.066406 10.515625 12.890625 10.503906 C 12.726562 10.496094 12.539062 10.496094 12.347656 10.496094 C 12.160156 10.496094 11.855469 10.566406 11.59375 10.847656 C 11.335938 11.132812 10.605469 11.816406 10.605469 13.207031 C 10.605469 14.597656 11.617188 15.941406 11.761719 16.132812 C 11.902344 16.320312 13.753906 19.175781 16.589844 20.398438 C 17.261719 20.691406 17.789062 20.863281 18.199219 20.996094 C 18.878906 21.210938 19.492188 21.179688 19.980469 21.105469 C 20.523438 21.027344 21.652344 20.421875 21.890625 19.761719 C 22.125 19.101562 22.125 18.535156 22.054688 18.417969 C 21.984375 18.300781 21.792969 18.230469 21.511719 18.089844 Z M 21.511719 18.089844 "/>
</g>
</svg>

          <p>Email</p>
        </a>
      </li>
      

      
      
      <li>
        <a href="mailto:?subject=Tutorial%20for%20CIoT%20Open%20Data%20Applications - 4.3.%20Time%20Series%20Data%20Clustering.&amp;body=4.3.%20Time%20Series%20Data%20Clustering%2c%20by%20Tutorial%20for%20CIoT%20Open%20Data%20Applications%0aWe%20introduce%20advanced%20data%20grouping%20analysis.%20We%20first%20present%20two%20time-series%20feature%20extraction%20methods%2c%20Fourier%20transform%20and%20wavelet%20transform%2c%20and%20briefly%20explain%20the%20similarities%20and%20differences%20between%20the%20two%20transform%20methods.%20We%20introduce%20two%20different%20time%20series%20comparison%20methods%2c%20Euclidean%20distance%20and%20dynamic%20time%20warping%20%28DTW%29%2c%20and%20apply%20existing%20clustering%20algorithms%20accordingly.%20We%20then%20discuss%20data%20clustering%20with%20different%20temporal%20resolutions%2c%20as%20well%20as%20their%20representation%20and%20potential%20applications%20in%20the%20real%20world.%0a%0ahttps%3a%2f%2fLearnCIOT.github.io%2fen%2fch4%2fch4.3%2f%0a" target="_blank" class="share-btn email">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
<defs>
<filter id="alpha" filterUnits="objectBoundingBox" x="0%" y="0%" width="100%" height="100%">
  <feColorMatrix type="matrix" in="SourceGraphic" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"/>
</filter>
<mask id="mask0">
  <g filter="url(#alpha)">
<rect x="0" y="0" width="32" height="32" style="fill:rgb(0%,0%,0%);fill-opacity:0.2;stroke:none;"/>
  </g>
</mask>
<clipPath id="clip1">
  <rect x="0" y="0" width="32" height="32"/>
</clipPath>
<g id="surface5" clip-path="url(#clip1)">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(13.72549%,12.156863%,12.54902%);fill-opacity:1;" d="M 26 22 C 26 23.101562 25.101562 24 24 24 L 8 24 C 6.898438 24 6 23.101562 6 22 L 6 12 C 6 10.898438 6.898438 10 8 10 L 24 10 C 25.101562 10 26 10.898438 26 12 Z M 26 22 "/>
</g>
<mask id="mask1">
  <g filter="url(#alpha)">
<rect x="0" y="0" width="32" height="32" style="fill:rgb(0%,0%,0%);fill-opacity:0.2;stroke:none;"/>
  </g>
</mask>
<clipPath id="clip2">
  <rect x="0" y="0" width="32" height="32"/>
</clipPath>
<g id="surface8" clip-path="url(#clip2)">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(13.72549%,12.156863%,12.54902%);fill-opacity:1;" d="M 17.75 15.101562 C 16.800781 14.050781 15.199219 14.050781 14.25 15.101562 L 6.5 21.601562 C 6.398438 21.699219 6.351562 21.800781 6.25 21.898438 C 6.601562 22.550781 7.25 23 7.949219 23 L 23.949219 23 C 24.699219 23 25.300781 22.550781 25.648438 21.898438 C 25.601562 21.800781 25.5 21.699219 25.398438 21.601562 Z M 17.75 15.101562 "/>
</g>
<mask id="mask2">
  <g filter="url(#alpha)">
<rect x="0" y="0" width="32" height="32" style="fill:rgb(0%,0%,0%);fill-opacity:0.2;stroke:none;"/>
  </g>
</mask>
<clipPath id="clip3">
  <rect x="0" y="0" width="32" height="32"/>
</clipPath>
<g id="surface11" clip-path="url(#clip3)">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(13.72549%,12.156863%,12.54902%);fill-opacity:1;" d="M 6.300781 10.101562 C 6.648438 9.449219 7.300781 9 8 9 L 24 9 C 24.75 9 25.351562 9.449219 25.699219 10.101562 C 25.648438 10.199219 25.550781 10.300781 25.449219 10.398438 L 17.75 16.898438 C 16.800781 17.949219 15.199219 17.949219 14.25 16.898438 Z M 6.300781 10.101562 "/>
</g>
</defs>
<g id="surface1">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(46.666667%,70.196078%,83.137255%);fill-opacity:1;" d="M 32 16 C 32 24.835938 24.835938 32 16 32 C 7.164062 32 0 24.835938 0 16 C 0 7.164062 7.164062 0 16 0 C 24.835938 0 32 7.164062 32 16 Z M 32 16 "/>
<use xlink:href="#surface5" mask="url(#mask0)"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(87.843137%,87.843137%,81.960784%);fill-opacity:1;" d="M 26 21 C 26 22.101562 25.101562 23 24 23 L 8 23 C 6.898438 23 6 22.101562 6 21 L 6 11 C 6 9.898438 6.898438 9 8 9 L 24 9 C 25.101562 9 26 9.898438 26 11 Z M 26 21 "/>
<use xlink:href="#surface8" mask="url(#mask1)"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(87.843137%,87.843137%,81.960784%);fill-opacity:1;" d="M 17.75 16 C 16.800781 15.050781 15.199219 15.050781 14.25 16 L 6.5 21.75 C 6.398438 21.851562 6.351562 21.898438 6.25 22 C 6.601562 22.601562 7.25 22.949219 7.949219 22.949219 L 23.949219 22.949219 C 24.699219 22.949219 25.300781 22.550781 25.648438 22 C 25.601562 21.898438 25.5 21.851562 25.398438 21.75 Z M 17.75 16 "/>
<use xlink:href="#surface11" mask="url(#mask2)"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 14.25 16 C 15.199219 16.949219 16.800781 16.949219 17.75 16 L 25.5 10.25 C 25.601562 10.148438 25.648438 10.101562 25.75 10 C 25.398438 9.398438 24.75 9.050781 24.050781 9.050781 L 8 9.050781 C 7.25 9.050781 6.648438 9.449219 6.300781 10 C 6.351562 10.101562 6.449219 10.148438 6.550781 10.25 Z M 14.25 16 "/>
</g>
</svg>

          <p>Email</p>
        </a>
      </li>
    </ul>
  </section>
  



<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZCH7EJS8LE"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-ZCH7EJS8LE', { 'anonymize_ip': false });
}
</script>



          <article class="default">
<h1>4.3. Time Series Data Clustering</h1>

<p><a href="https://colab.research.google.com/drive/1n01pJ_3HlUN3iOru3G1E9onkUlSfu-Z6?usp=sharing"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></p>
<div>
    <h2>Table Of Contents</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#goal">Goal</a></li>
    <li><a href="#package-installation-and-importing">Package Installation and Importing</a></li>
    <li><a href="#data-access-and-preprocessing">Data Access and Preprocessing</a></li>
    <li><a href="#data-clustering">Data Clustering</a>
      <ul>
        <li><a href="#fast-fourier-transform">Fast Fourier Transform</a></li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
</div>

<p>Cluster analysis is a popular technique in data science aimed at identifying groups, or &lsquo;clusters&rsquo;, of similar data points. This method helps organize data by grouping similar items together, making it easier for researchers to conduct more detailed analyses on these sets. In the context of Civil IoT Taiwan, where the data from sensors is in the form of time series (data points collected over time), this approach is especially useful. To effectively group numerous sensors for comprehensive data analysis, standard methods for extracting key features are used. These methods help in classifying time series data into clusters for more insightful analysis.</p>
<h2 id="goal">Goal</h2>
<ul>
<li>Understand how to apply Fast Fourier Transform (FFT) and Wavelet Transform for feature extraction in time series data. These techniques help in breaking down complex data patterns into simpler components, making it easier to analyze and understand the data.</li>
<li>Employ unsupervised learning methods for clustering time series data. This approach doesn&rsquo;t rely on pre-labeled data; instead, it discovers natural groupings within the data based on the similarities and differences in the data points.</li>
</ul>
<h2 id="package-installation-and-importing">Package Installation and Importing</h2>
<p>In this guide, we&rsquo;ll be using several pre-installed packages on our development platform, Google Colab. These include pandas, matplotlib, numpy, and pywt, all of which are ready to use without any manual installation. However, there&rsquo;s an additional package, tslearn, that isn&rsquo;t pre-installed on Colab. We&rsquo;ll need to install this package separately. To do so, we&rsquo;ll follow a specific installation process which I&rsquo;ll describe next.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>pip install <span style="color:#f92672">--</span>upgrade pip <span style="color:#75715e"># This command upgrades &#39;pip&#39; to the latest version. &#39;pip&#39; is the package installer for Python, used to install and manage software packages.</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>pip install tslearn <span style="color:#75715e"># This command installs the &#39;tslearn&#39; package. &#39;tslearn&#39; is a machine learning library for time series analysis in Python.</span>
</span></span></code></pre></div><p>Once the installation is finished, we can start importing the necessary packages to set up our workspace for this tutorial. Here&rsquo;s how we&rsquo;ll do it: we&rsquo;ll use a specific syntax to import each of these packages into our coding environment. This step is crucial as it prepares our platform with all the tools we need for the tasks ahead in this guide.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np <span style="color:#75715e"># Imports NumPy, a library for numerical operations. &#39;np&#39; is a common alias used for NumPy.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd <span style="color:#75715e"># Imports Pandas, a library for data manipulation and analysis. &#39;pd&#39; is a standard alias for Pandas.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pywt <span style="color:#75715e"># Imports PyWavelets, a library for wavelet transformation, often used for signal processing.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os<span style="color:#f92672">,</span> zipfile <span style="color:#75715e"># Imports &#39;os&#39; and &#39;zipfile&#39; for operating system interactions and handling zip files, respectively.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt <span style="color:#75715e"># Imports Matplotlib&#39;s &#39;pyplot&#39;, a plotting library. &#39;plt&#39; is a conventional alias.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> datetime <span style="color:#f92672">import</span> datetime, timedelta <span style="color:#75715e"># Imports specific classes from the &#39;datetime&#39; module for handling dates and times.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> numpy.fft <span style="color:#f92672">import</span> fft, ifft <span style="color:#75715e"># Imports &#39;fft&#39; and &#39;ifft&#39; from NumPy&#39;s Fast Fourier Transform (FFT) sub-module for frequency domain transformations.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pywt <span style="color:#f92672">import</span> cwt <span style="color:#75715e"># Imports &#39;cwt&#39; (Continuous Wavelet Transform) from PyWavelets for time-frequency analysis.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> tslearn.clustering <span style="color:#f92672">import</span> TimeSeriesKMeans <span style="color:#75715e"># Imports TimeSeriesKMeans for clustering time series data from the &#39;tslearn&#39; library.</span>
</span></span></code></pre></div><h2 id="data-access-and-preprocessing">Data Access and Preprocessing</h2>
<p>In this tutorial, we&rsquo;re focusing on using long-term historical data. Instead of accessing data through the standard methods provided by the pyCIOT package, we&rsquo;ll take a different approach. We&rsquo;ll directly download the 2021 data archive of the &ldquo;Academia Sinica - Micro Air Quality Sensors&rdquo; from the historical database of the Civil IoT Taiwan Data Service Platform. Once downloaded, this data will be stored in a folder named <code>Air</code>. This method allows us to work with a comprehensive dataset, giving us a broader view of the historical trends and patterns.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>mkdir Air CSV_Air <span style="color:#75715e"># Creates two directories: &#39;Air&#39; and &#39;CSV_Air&#39;. These will be used to store downloaded and extracted data.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This command uses &#39;wget&#39; to download a file from the provided URL. </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The &#39;-O Air/2021.zip&#39; option specifies that the downloaded file should be named &#39;2021.zip&#39; and saved in the &#39;Air&#39; directory.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The &#39;-q&#39; option runs the command in quiet mode, suppressing most of the command output.</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>wget <span style="color:#f92672">-</span>O Air<span style="color:#f92672">/</span><span style="color:#ae81ff">2021.</span>zip <span style="color:#f92672">-</span>q <span style="color:#e6db74">&#34;https://history.colife.org.tw/?r=/download&amp;path=L%2Bepuuawo%2BWTgeizqi</span><span style="color:#e6db74">%2F</span><span style="color:#e6db74">kuK3noJTpmaJf5qCh5ZyS56m65ZOB5b6u5Z6L5oSf5ris5ZmoLzIwMjEuemlw&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>unzip Air<span style="color:#f92672">/</span><span style="color:#ae81ff">2021.</span>zip <span style="color:#f92672">-</span>d Air <span style="color:#75715e"># This command unzips the contents of &#39;2021.zip&#39; into the &#39;Air&#39; directory.</span>
</span></span></code></pre></div><p>As we proceed, it&rsquo;s important to note that the data we download will be in a zip file format. This means our first step is to unzip this file. Doing so will reveal a collection of daily files, each also compressed. Specifically, we&rsquo;ll focus on the data from August 2021. Our task is to decompress these daily files for this month and then store the contents from these unzipped CSV files into a dataframe, which we will refer to as <code>air_month</code>. This process enables us to organize and access the data efficiently for our analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>folder <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Air/2021/202108&#39;</span> <span style="color:#75715e"># Sets the folder path where the data is stored.</span>
</span></span><span style="display:flex;"><span>extension_zip <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;zip&#39;</span> <span style="color:#75715e"># Defines the extension for zip files.</span>
</span></span><span style="display:flex;"><span>extension_csv <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;csv&#39;</span> <span style="color:#75715e"># Defines the extension for CSV files.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Loop to extract files from zip archives in the specified folder</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>listdir(folder): 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> item<span style="color:#f92672">.</span>endswith(extension_zip): <span style="color:#75715e"># Checks if the file is a zip file.</span>
</span></span><span style="display:flex;"><span>    file_name <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>folder<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">{</span>item<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span> <span style="color:#75715e"># Creates the full path for the zip file.</span>
</span></span><span style="display:flex;"><span>    zip_ref <span style="color:#f92672">=</span> zipfile<span style="color:#f92672">.</span>ZipFile(file_name) <span style="color:#75715e"># Opens the zip file.</span>
</span></span><span style="display:flex;"><span>    zip_ref<span style="color:#f92672">.</span>extractall(folder) <span style="color:#75715e"># Extracts all contents to the folder.</span>
</span></span><span style="display:flex;"><span>    zip_ref<span style="color:#f92672">.</span>close() <span style="color:#75715e"># Closes the zip file.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>air_month <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame() <span style="color:#75715e"># Initializes an empty DataFrame to store the combined data.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Loop to read CSV files and append them to the DataFrame</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>listdir(folder):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> item<span style="color:#f92672">.</span>endswith(extension_csv): <span style="color:#75715e"># Checks if the file is a CSV file.</span>
</span></span><span style="display:flex;"><span>    file_name <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>folder<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">{</span>item<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span> <span style="color:#75715e"># Creates the full path for the CSV file.</span>
</span></span><span style="display:flex;"><span>    df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(file_name, parse_dates<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;timestamp&#39;</span>]) <span style="color:#75715e"># Reads the CSV file into a DataFrame, parsing &#39;timestamp&#39; as dates.</span>
</span></span><span style="display:flex;"><span>    air_month <span style="color:#f92672">=</span> air_month<span style="color:#f92672">.</span>append(df) <span style="color:#75715e"># Appends the DataFrame to &#39;air_month&#39;.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting &#39;timestamp&#39; as the index and sorting the DataFrame</span>
</span></span><span style="display:flex;"><span>air_month<span style="color:#f92672">.</span>set_index(<span style="color:#e6db74">&#39;timestamp&#39;</span>, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>) <span style="color:#75715e"># Sets &#39;timestamp&#39; as the index of the DataFrame.</span>
</span></span><span style="display:flex;"><span>air_month<span style="color:#f92672">.</span>sort_values(by<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>) <span style="color:#75715e"># Sorts the DataFrame by &#39;timestamp&#39;.</span>
</span></span></code></pre></div><p>Currently, the <code>air_month</code> dataframe isn&rsquo;t structured in a way that suits our analysis needs. We need to rearrange it so that the data from different sites are in separate columns, and time data is organized in rows. To start this reformatting process, our first step is to identify all the unique sites represented in our data. We&rsquo;ll gather this information and store it in a sequence. This step is essential for understanding the range of locations our data covers, and it will help us in efficiently restructuring the <code>air_month</code> dataframe for more effective data analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Extract the &#39;device_id&#39; column from the &#39;air_month&#39; DataFrame and convert it to a NumPy array.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &#39;device_id&#39; contains the IDs of the devices used for air quality measurement.</span>
</span></span><span style="display:flex;"><span>id_list <span style="color:#f92672">=</span> air_month[<span style="color:#e6db74">&#39;device_id&#39;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use NumPy&#39;s &#39;unique&#39; function to find all the unique device IDs in the array.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This removes any duplicate IDs, giving us a list of distinct devices used in the data collection.</span>
</span></span><span style="display:flex;"><span>id_uniques <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>unique(id_list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The variable &#39;id_uniques&#39; now holds the unique device IDs from your dataset.</span>
</span></span><span style="display:flex;"><span>id_uniques
</span></span></code></pre></div><pre tabindex="0"><code>array([&#39;08BEAC07D3E2&#39;, &#39;08BEAC09FF12&#39;, &#39;08BEAC09FF22&#39;, ...,
       &#39;74DA38F7C648&#39;, &#39;74DA38F7C64A&#39;, &#39;74DA38F7C64C&#39;], dtype=object)
</code></pre><p>Next, we&rsquo;ll organize the data from each unique site into its own column, compiling all these columns into a new dataframe named <code>air</code>. This structure will make the data more accessible and easier to analyze, with each site&rsquo;s data clearly separated and organized chronologically.</p>
<p>After completing this step, it&rsquo;s important to clean up our workspace. We&rsquo;ll do this by deleting all the originally downloaded and unpacked data files. This cleanup is crucial for conserving cloud storage space, ensuring our workspace remains efficient and uncluttered. This practice is not only good for organization but also essential in a cloud computing environment where storage space and neatness are key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Initialize an empty DataFrame &#39;air&#39; to store aggregated data.</span>
</span></span><span style="display:flex;"><span>air <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate over each unique device ID.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(id_uniques)):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construct a query string to filter data for the current device ID.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This step is essential for processing data device-wise.</span>
</span></span><span style="display:flex;"><span>    query <span style="color:#f92672">=</span> air_month<span style="color:#f92672">.</span>query(<span style="color:#e6db74">&#39;device_id==&#34;&#39;</span> <span style="color:#f92672">+</span> id_uniques[i] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;&#34;&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Sort the filtered data by &#39;timestamp&#39; to ensure chronological order.</span>
</span></span><span style="display:flex;"><span>    query<span style="color:#f92672">.</span>sort_values(by<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Resample the data to an hourly frequency and compute the mean for each hour.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This step aggregates the data, making it more manageable and easier to analyze.</span>
</span></span><span style="display:flex;"><span>    query_mean <span style="color:#f92672">=</span> query<span style="color:#f92672">.</span>resample(<span style="color:#e6db74">&#39;H&#39;</span>)<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Rename the &#39;PM25&#39; column to the current device ID for clarity.</span>
</span></span><span style="display:flex;"><span>    query_mean<span style="color:#f92672">.</span>rename(columns<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;PM25&#39;</span>: id_uniques[i]}, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Concatenate the processed data for the current device to the &#39;air&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># The &#39;axis=1&#39; parameter indicates a horizontal concatenation (column-wise).</span>
</span></span><span style="display:flex;"><span>    air <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>concat([air, query_mean], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">!</span>rm <span style="color:#f92672">-</span>rf Air
</span></span></code></pre></div><p>To quickly inspect the contents of our newly organized <code>air</code> dataframe, we can use a specific syntax. This command will display a snapshot of the dataframe, allowing us to verify its structure and the data it contains. This step is important for ensuring that our data reorganization was successful and that the dataframe is ready for further analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Displaying the structure and summary information of the &#39;air&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>air<span style="color:#f92672">.</span>info()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the first five rows of the &#39;air&#39; DataFrame to get a quick overview of the data.</span>
</span></span><span style="display:flex;"><span>print(air<span style="color:#f92672">.</span>head())
</span></span></code></pre></div><pre tabindex="0"><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
DatetimeIndex: 745 entries, 2021-08-01 00:00:00 to 2021-09-01 00:00:00
Freq: H
Columns: 1142 entries, 08BEAC07D3E2 to 74DA38F7C64C
dtypes: float64(1142)
memory usage: 6.5 MB
                     08BEAC07D3E2  08BEAC09FF12  08BEAC09FF22  08BEAC09FF2A  \
timestamp                                                                     
2021-08-01 00:00:00      2.272727      1.250000     16.818182     12.100000   
2021-08-01 01:00:00      1.909091      1.285714     13.181818     14.545455   
2021-08-01 02:00:00      2.000000      1.125000     12.727273     16.600000   
2021-08-01 03:00:00      2.083333      3.000000     11.800000     12.090909   
2021-08-01 04:00:00      2.000000      2.600000     10.090909      8.545455   

                     08BEAC09FF34  08BEAC09FF38  08BEAC09FF42  08BEAC09FF44  \
timestamp                                                                     
2021-08-01 00:00:00      2.727273      0.000000      1.181818           NaN   
2021-08-01 01:00:00      2.000000      0.545455      0.909091           NaN   
2021-08-01 02:00:00      4.090909      1.583333      0.636364           NaN   
2021-08-01 03:00:00      0.545455      1.454545      1.181818           NaN   
2021-08-01 04:00:00      1.363636      1.363636      2.454545           NaN   

                     08BEAC09FF46  08BEAC09FF48  ...  74DA38F7C62A  \
timestamp                                        ...                 
2021-08-01 00:00:00      2.636364      2.545455  ...      6.777778   
2021-08-01 01:00:00      1.636364      2.272727  ...      7.800000   
2021-08-01 02:00:00      1.400000      3.100000  ...      7.300000   
2021-08-01 03:00:00      2.181818      4.000000  ...     12.000000   
2021-08-01 04:00:00      1.909091      2.100000  ...      9.000000   

                     74DA38F7C630  74DA38F7C632  74DA38F7C634  74DA38F7C63C  \
timestamp                                                                     
2021-08-01 00:00:00      9.800000     13.200000           5.0      6.200000   
2021-08-01 01:00:00     13.000000     15.700000           5.2      6.800000   
2021-08-01 02:00:00     12.800000     19.300000           5.0      7.300000   
2021-08-01 03:00:00      8.444444     15.200000           5.1      6.777778   
2021-08-01 04:00:00      6.500000     10.222222           4.9      6.100000   

                     74DA38F7C63E  74DA38F7C640  74DA38F7C648  74DA38F7C64A  \
timestamp                                                                     
2021-08-01 00:00:00           NaN      7.500000      5.000000      9.000000   
2021-08-01 01:00:00           NaN     10.200000      4.900000      6.600000   
2021-08-01 02:00:00           NaN     10.500000      3.666667      7.600000   
2021-08-01 03:00:00           NaN      8.500000      8.400000      8.000000   
2021-08-01 04:00:00           NaN      5.571429      6.200000      5.666667   

                     74DA38F7C64C  
timestamp                          
2021-08-01 00:00:00      7.600000  
2021-08-01 01:00:00      7.700000  
2021-08-01 02:00:00      7.888889  
2021-08-01 03:00:00      6.400000  
2021-08-01 04:00:00      5.000000  
</code></pre><p>Moving forward, our next step involves cleaning the data in the <code>air</code> dataframe. We&rsquo;ll specifically focus on removing any parts of the data that contain missing values, often represented as &lsquo;NaN&rsquo; (Not a Number). This step is crucial for ensuring the accuracy and reliability of our analysis.</p>
<p>Once we&rsquo;ve cleaned the data by removing these missing values, the next step is to visualize the data. We&rsquo;ll do this by plotting the data in a graph. This visualization will help us to observe and understand the distribution and patterns within the data more clearly. Graphical representation is a powerful tool for gaining insights and making data more accessible and interpretable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Removing the last row from the &#39;air&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>air <span style="color:#f92672">=</span> air[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Creating a new DataFrame &#39;air_clean&#39; by dropping columns with any missing values.</span>
</span></span><span style="display:flex;"><span>air_clean <span style="color:#f92672">=</span> air<span style="color:#f92672">.</span>dropna(<span style="color:#ae81ff">1</span>, how<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;any&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plotting the data in &#39;air_clean&#39; with a specified figure size and without displaying the legend.</span>
</span></span><span style="display:flex;"><span>air_clean<span style="color:#f92672">.</span>plot(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">15</span>), legend<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><p><img src="figures/4-3-3-1.png" alt="Python output"></p>
<p>The original data from the sensor can show sudden and dramatic changes because of changes in the environment. To make this data more consistent and reliable, we apply a technique called the moving average method. This approach averages the sensor readings every ten instances. By doing this, the resulting data becomes smoother and more stable. It also more accurately shows the general trends in the area around the sensor, which is helpful for the next step of our analysis, known as cluster analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Applying a rolling mean with a window of 10 and a minimum of 1 period to the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>air_clean <span style="color:#f92672">=</span> air_clean<span style="color:#f92672">.</span>rolling(window<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, min_periods<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plotting the modified &#39;air_clean&#39; data with a specified figure size and without a legend.</span>
</span></span><span style="display:flex;"><span>air_clean<span style="color:#f92672">.</span>plot(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">15</span>), legend<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><p><img src="figures/4-3-3-2.png" alt="Python output"></p>
<h2 id="data-clustering">Data Clustering</h2>
<p>In our current data setup, each weather station&rsquo;s data is placed in a separate column in a dataframe, with each row showing the sensor readings from all stations at a specific moment. This layout is good for analyzing data over time, but not as useful for grouping data. To prepare for data grouping, we first need to rearrange the data by transposing it, essentially switching the rows and columns.</p>
<p>Data clustering is a popular technique in data science, and we&rsquo;re using a specific method called KMeans clustering, provided by the <code>tslearn</code> package. This method falls under &lsquo;unsupervised learning&rsquo; in machine learning. Unlike other methods where data is sorted into groups based on predefined criteria, KMeans clustering groups data based on how similar the data points are to each other. This makes it great for identifying unusual data points or for making predictions.</p>
<p>Here&rsquo;s how the KMeans clustering process works:</p>
<ol>
<li>Choose the number of clusters, <em>k</em>. We decide how many groups we want to create.</li>
<li>Randomly pick <em>k</em> data points as the starting points for these clusters, known as &lsquo;cluster heads.&rsquo;</li>
<li>Measure how close each data point is to these cluster heads, and assign each point to the nearest cluster.</li>
<li>Update the center of each cluster based on the points assigned to it, and repeat the process until the cluster heads don&rsquo;t change anymore.</li>
</ol>
<p>We&rsquo;ll start by setting <em>k=10</em>, meaning we want to create 10 clusters. Using <code>TimeSeriesKMeans</code>, we&rsquo;ll divide the data into these 10 groups, labeled from 0 to 9.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Transposing the &#39;air_clean&#39; DataFrame for time series clustering.</span>
</span></span><span style="display:flex;"><span>air_transpose <span style="color:#f92672">=</span> air_clean<span style="color:#f92672">.</span>transpose()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initializing the Time Series K-Means model with 10 clusters, using the DTW (Dynamic Time Warping) metric, and setting a maximum of 5 iterations.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &#39;n_clusters&#39; specifies the number of clusters, &#39;max_iter&#39; sets the maximum number of iterations for the clustering process.</span>
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> TimeSeriesKMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dtw&#34;</span>, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>) <span style="color:#75715e"># n_cluster:, max_iter: </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Fitting the model to the transposed &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>pre <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>fit(air_transpose)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Retrieving the cluster labels for each time series in the dataset.</span>
</span></span><span style="display:flex;"><span>pre<span style="color:#f92672">.</span>labels_
</span></span></code></pre></div><pre tabindex="0"><code>array([3, 3, 6, 3, 3, 3, 3, 6, 9, 6, 3, 6, 3, 3, 3, 3, 3, 1, 3, 3, 6, 3,
3, 3, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 3, 9, 3, 3, 3,
3, 3, 6, 3, 2, 6, 3, 2, 3, 3, 3, 6, 9, 3, 3, 3, 3, 6, 6, 3, 3, 3,
6, 6, 3, 3, 3, 3, 3, 6, 3, 6, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 6, 3,
3, 3, 6, 3, 3, 3, 3, 3, 3, 6, 9, 6, 7, 3, 2, 3, 6, 3, 3, 3, 6, 3,
3, 3, 3, 6, 3, 3, 3, 6, 3, 6, 6, 3, 6, 3, 3, 3, 3, 6, 3, 3, 3, 3,
3, 3, 3, 3, 3, 3, 3, 0, 3, 6, 3, 3, 3, 0, 6, 0, 6, 3, 0, 3, 3, 3,
6, 6, 6, 6, 3, 3, 6, 3, 3, 9, 6, 3, 6, 3, 6, 6, 3, 2, 3, 3, 3, 6,
9, 6, 6, 3, 3, 6, 3, 0, 3, 3, 6, 6, 6, 3, 0, 0, 6, 3, 6, 6, 6, 3,
6, 6, 3, 0, 3, 3, 0, 3, 3, 6, 3, 6, 6, 6, 3, 0, 3, 0, 0, 0, 9, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 9, 9, 0, 0, 0, 4,
9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 0, 0, 9, 9, 0, 9, 0,
0, 0, 5, 0, 0, 0, 0, 9, 9, 0, 1, 0, 9, 2, 9, 9, 0, 0, 5, 0, 9, 0,
9, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 2, 3, 3, 0, 3, 0, 0, 0, 6, 3, 0,
8, 9, 3, 9, 9, 0, 5, 0, 3, 0, 9, 9, 5, 5, 5, 3, 5, 9, 3, 0, 0, 3,
0, 0, 0, 3, 5, 5, 3, 0, 5, 6, 5, 5, 5, 0, 9, 0, 6, 6, 6, 3, 0, 3,
5, 5, 9, 6, 3, 0, 0, 0, 0, 3, 5, 0, 5, 5, 0, 3, 3, 9, 5, 5, 9, 5,
9, 9, 9, 9, 5, 5, 5, 5, 5, 5, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 5,
5, 5])
</code></pre><p>After we apply the clustering method, sometimes we find that certain sensors form their own cluster because their data is unique. These sensors are outliers and generally don&rsquo;t provide useful information for further analysis. So, our next step is to check if any cluster contains only a single sensor. If it does, we consider this cluster irrelevant and remove it from our analysis. For instance, in our current case, we will eliminate any cluster that is made up of just one sensor, as shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Creating a DataFrame &#39;df_cluster&#39; to map each metric in &#39;air_clean&#39; to its corresponding cluster label.</span>
</span></span><span style="display:flex;"><span>df_cluster <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(list(zip(air_clean<span style="color:#f92672">.</span>columns, pre<span style="color:#f92672">.</span>labels_)), columns<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;metric&#39;</span>, <span style="color:#e6db74">&#39;cluster&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cluster_metrics_dict <span style="color:#f92672">=</span> df_cluster<span style="color:#f92672">.</span>groupby([<span style="color:#e6db74">&#39;cluster&#39;</span>])[<span style="color:#e6db74">&#39;metric&#39;</span>]<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> x])<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_metrics_dict&#39; that maps each cluster to the metrics it contains.</span>
</span></span><span style="display:flex;"><span>cluster_len_dict <span style="color:#f92672">=</span> df_cluster[<span style="color:#e6db74">&#39;cluster&#39;</span>]<span style="color:#f92672">.</span>value_counts()<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_len_dict&#39; to count the number of metrics in each cluster.</span>
</span></span><span style="display:flex;"><span>clusters_dropped <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a list &#39;clusters_dropped&#39; containing clusters with only one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a sorted list &#39;clusters_final&#39; containing clusters with more than one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Outputting the list of clusters that were dropped.</span>
</span></span><span style="display:flex;"><span>clusters_dropped
</span></span></code></pre></div><pre tabindex="0"><code>[7, 4, 8]
</code></pre><p>In the final step, we visually present the clusters that remain after removing the irrelevant ones. When we look at these clusters, it&rsquo;s clear that the data within each cluster are very similar to each other, while the data across different clusters show noticeable differences. To measure how similar the data is within each cluster, we introduce a new metric called <code>quality</code>.</p>
<p>The <code>quality</code> of a cluster is calculated by averaging the correlation between each piece of data within the cluster and all other data in that same cluster. The idea is that the lower the <code>quality</code> value, the more alike the data in that cluster is. In other words, a lower <code>quality</code> score indicates a high degree of similarity among the data points in a cluster.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Creating a subplot for each cluster in &#39;clusters_final&#39; with specific dimensions and resolution.</span>
</span></span><span style="display:flex;"><span>fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(nrows<span style="color:#f92672">=</span>len(clusters_final), ncols<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">15</span>), dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterating over each cluster to create individual plots.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, cluster_number <span style="color:#f92672">in</span> enumerate(clusters_final):
</span></span><span style="display:flex;"><span>  x_corr <span style="color:#f92672">=</span> air_clean[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>corr()<span style="color:#f92672">.</span>abs()<span style="color:#f92672">.</span>values <span style="color:#75715e"># Calculating the absolute correlation matrix for the metrics in the current cluster.</span>
</span></span><span style="display:flex;"><span>  x_corr_mean <span style="color:#f92672">=</span> round(x_corr[np<span style="color:#f92672">.</span>triu_indices(x_corr<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">1</span>)]<span style="color:#f92672">.</span>mean(),<span style="color:#ae81ff">2</span>) <span style="color:#75715e"># Calculating the mean of the upper triangle of the correlation matrix, rounding to two decimal places.</span>
</span></span><span style="display:flex;"><span>  plot_title <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;cluster </span><span style="color:#e6db74">{</span>cluster_number<span style="color:#e6db74">}</span><span style="color:#e6db74"> (quality=</span><span style="color:#e6db74">{</span>x_corr_mean<span style="color:#e6db74">}</span><span style="color:#e6db74">, n=</span><span style="color:#e6db74">{</span>cluster_len_dict[cluster_number]<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#39;</span> <span style="color:#75715e"># Creating a title for the plot with cluster number, quality (mean correlation), and number of metrics.</span>
</span></span><span style="display:flex;"><span>  air_clean[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>plot(ax<span style="color:#f92672">=</span>axes[idx], title<span style="color:#f92672">=</span>plot_title) <span style="color:#75715e"># Plotting the metrics in the current cluster on the respective subplot.</span>
</span></span><span style="display:flex;"><span>  axes[idx]<span style="color:#f92672">.</span>get_legend()<span style="color:#f92672">.</span>remove() <span style="color:#75715e"># Removing the legend from each subplot for clarity.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Adjusting the layout for better visibility and aesthetics.</span>
</span></span><span style="display:flex;"><span>fig<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Displaying the plot.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="figures/4-3-4-1.png" alt="Python output"></p>
<p>In our analysis, we&rsquo;ve shown how to cluster air quality sensor data based on specific characteristics in the data. However, it&rsquo;s important to note that the original data might have some noise - unwanted variations or disturbances. This noise can affect the accuracy of our clustering results. To minimize the impact of this noise, we use two advanced methods: the Fourier transform and the wavelet transform. These methods help us extract more refined features from the time series data, which in turn improves the quality of our clustering.</p>
<h3 id="fast-fourier-transform">Fast Fourier Transform</h3>
<p>The Fourier transform is a widely used method in signal analysis. It transforms data from the time domain to the frequency domain, making it easier to extract features and analyze the data. This technique is essential in fields like engineering and mathematics and is particularly useful in analyzing sound and time series data.</p>
<p>However, the standard Fourier transform involves complex mathematical computations, making it impractical for large datasets due to its time-consuming nature. To address this, the Fast Fourier Transform (FFT) was developed. FFT is a quicker way to perform the Fourier transform, significantly reducing the complexity and computational time, especially when dealing with large amounts of data.</p>
<p>In our next step, we&rsquo;ll use the Fast Fourier Transform method to extract relevant features for data grouping. To start, we&rsquo;ll examine the time variation of a single station&rsquo;s data (identified by the ID &lsquo;&rsquo;<code>08BEAC07D3E2</code>&rsquo;&rsquo;) by creating a plot. This will give us a clearer understanding of how this method works and its effectiveness in our analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Plotting the time series data for the column &#39;08BEAC07D3E2&#39; in the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>air_clean[<span style="color:#e6db74">&#39;08BEAC07D3E2&#39;</span>]<span style="color:#f92672">.</span>plot()
</span></span></code></pre></div><p><img src="figures/4-3-4-2.png" alt="Python output"></p>
<p>Next, we&rsquo;ll use the Fast Fourier Transform (FFT) tool, specifically the <code>fft</code> function from the NumPy package, to transform the data from our chosen station. By applying FFT, we change the way we view the data, shifting from the time domain to the frequency domain. This shift is key in analyzing and understanding the underlying patterns and characteristics of the data.</p>
<p>Once we&rsquo;ve applied the FFT to the station&rsquo;s data, we&rsquo;ll visually represent the transformed data. This involves creating a graph to show how the data is distributed in the frequency domain after the transformation. This graphical representation will help us better understand the nature of the data and the impact of the FFT, illustrating the key features and patterns that emerge when we view the data through the lens of frequency rather than time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Performing Fast Fourier Transform (FFT) on the &#39;08BEAC07D3E2&#39; column of the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> fft(air_clean[<span style="color:#e6db74">&#39;08BEAC07D3E2&#39;</span>])
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> len(X)
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Determining the sampling rate, assuming each data point represents an hourly interval.</span>
</span></span><span style="display:flex;"><span>sr <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">60</span><span style="color:#f92672">*</span><span style="color:#ae81ff">60</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calculating the total time duration of the dataset.</span>
</span></span><span style="display:flex;"><span>T <span style="color:#f92672">=</span> N<span style="color:#f92672">/</span>sr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Computing the frequency array.</span>
</span></span><span style="display:flex;"><span>freq <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>T 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Limiting the spectrum to one-sided (since FFT output is symmetric for real-valued inputs).</span>
</span></span><span style="display:flex;"><span>n_oneside <span style="color:#f92672">=</span> N <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Considering only the one-sided frequencies.</span>
</span></span><span style="display:flex;"><span>n_oneside <span style="color:#f92672">=</span> N<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># get the one side frequency</span>
</span></span><span style="display:flex;"><span>f_oneside <span style="color:#f92672">=</span> freq[:n_oneside]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plotting the one-sided spectrum.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize <span style="color:#f92672">=</span> (<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(f_oneside, np<span style="color:#f92672">.</span>abs(X[:n_oneside]), <span style="color:#e6db74">&#39;b&#39;</span>) <span style="color:#75715e"># &#39;b&#39; specifies the color blue for the plot.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;Freq (Hz)&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;FFT Amplitude |X(freq)|&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="figures/4-3-4-3.png" alt="Python output"></p>
<p>After successfully applying the Fast Fourier Transform (FFT) to the data from one station and analyzing its frequency domain representation, our next step is to extend this transformation to all the sensors in our dataset. We will apply the FFT tool from the NumPy package to each sensor&rsquo;s data, converting their time-domain data into the frequency domain.</p>
<p>Once we&rsquo;ve transformed the data from all sensors using FFT, we will collect and store these results in a variable named <code>air_fft</code>. This variable will hold the frequency domain data for each sensor, allowing us to analyze and compare the transformed data across all sensors. This comprehensive approach helps us gain a deeper understanding of the entire dataset, revealing patterns and insights that might not be evident when looking at individual sensors or the time-domain data alone.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Initializing an empty DataFrame to store the FFT results.</span>
</span></span><span style="display:flex;"><span>air_fft <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Getting the column names from the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>col_names <span style="color:#f92672">=</span> list(air_clean<span style="color:#f92672">.</span>columns)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Looping through each column in &#39;air_clean&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> name <span style="color:#f92672">in</span> col_names:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Performing FFT on the column.</span>
</span></span><span style="display:flex;"><span>  X <span style="color:#f92672">=</span> fft(air_clean[name])
</span></span><span style="display:flex;"><span>  N <span style="color:#f92672">=</span> len(X)
</span></span><span style="display:flex;"><span>  n <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Determining the sampling rate (assuming hourly data).</span>
</span></span><span style="display:flex;"><span>  sr <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">60</span><span style="color:#f92672">*</span><span style="color:#ae81ff">60</span>) <span style="color:#75715e"># 1 hour in seconds</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Calculating the total time duration.</span>
</span></span><span style="display:flex;"><span>  T <span style="color:#f92672">=</span> N<span style="color:#f92672">/</span>sr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Computing the frequency array.</span>
</span></span><span style="display:flex;"><span>  freq <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>T 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Limiting the FFT output to one-sided.</span>
</span></span><span style="display:flex;"><span>  n_oneside <span style="color:#f92672">=</span> N<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Getting the one-sided frequency array.</span>
</span></span><span style="display:flex;"><span>  f_oneside <span style="color:#f92672">=</span> freq[:n_oneside]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Storing the amplitude of the one-sided FFT in the &#39;air_fft&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>  air_fft[name] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>abs(X[:n_oneside])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the first five rows of the &#39;air_fft&#39; DataFrame to verify the results.</span>
</span></span><span style="display:flex;"><span>print(air_fft<span style="color:#f92672">.</span>head())
</span></span></code></pre></div><pre tabindex="0"><code>08BEAC07D3E2  08BEAC09FF22  08BEAC09FF2A  08BEAC09FF42  08BEAC09FF48  \
0  12019.941563  11255.762431  13241.408211  12111.740447  11798.584351   
1   3275.369377   2640.372699   1501.672853   3096.493565   3103.006928   
2   1109.613670   1201.362571    257.659947   1085.384353   1128.373457   
3   2415.899146   1631.128345    888.838822   2281.597031   2301.936400   
4   1130.973327    446.032078    411.940722   1206.512460   1042.054041   

   08BEAC09FF66  08BEAC09FF80  08BEAC09FF82  08BEAC09FF8C  08BEAC09FF9C  ...  \
0  12441.845754  11874.390693  12259.096742   3553.255916  13531.649701  ...   
1   3262.357287   2999.042917   1459.720167   1109.764942    646.846038  ...   
2   1075.877632   1005.445596    478.569869    368.572815   1163.425916  ...   
3   2448.646527   2318.870954    956.029693    272.486798    553.409732  ...   
4   1087.461354   1172.755489    437.920193    471.824176    703.557830  ...   

   74DA38F7C504  74DA38F7C514  74DA38F7C524  74DA38F7C554  74DA38F7C5BA  \
0  11502.841221  10589.689400  11220.068048  10120.220198  11117.146124   
1   2064.762890   1407.105290   1938.647888   1126.088084   2422.787262   
2   2163.528535   1669.014077   2054.586664   1759.326882   1782.523300   
3   1564.407983   1157.759192   1253.849261   1244.799149   1519.477057   
4   1484.232397   1177.909914   1318.704021   1106.349846   1373.167639   

   74DA38F7C5BC  74DA38F7C5E0  74DA38F7C60C  74DA38F7C62A  74DA38F7C648  
0  11243.094213     26.858333   9408.414826  11228.246949   8931.871618  
1   2097.343959     15.020106   1667.485473   1687.251179   1395.239491  
2   1806.524987     10.659603   1585.987276   1851.628868   1527.925427  
3   1521.392873      6.021244   1217.547879   1240.173667   1022.239794  
4   1393.469185      3.361938   1161.975844   1350.756178   1051.434944  

[5 rows x 398 columns]
</code></pre><p>After transforming all sensor data into the frequency domain using the Fast Fourier Transform (FFT), we proceed to the next step: clustering this transformed data. We use the same <code>TimeSeriesKMeans</code> method as before, but this time, we apply it to the frequency-domain data. Our goal is to divide this data into 10 distinct clusters.</p>
<p>Following the clustering, we&rsquo;ll review the composition of each cluster. Any cluster that contains only a single sensor will be considered irrelevant and removed from our analysis, just like we did earlier. This is because a cluster with only one sensor doesn&rsquo;t provide valuable comparative information.</p>
<p>In this specific example, after removing the single-sensor clusters, we end up with 9 clusters. We then document and display the cluster each sensor belongs to by printing their cluster codes. This process helps us understand how the sensors group together based on their frequency-domain data, offering insights that differ from the time-domain analysis. By comparing these clusters, we can gain a more nuanced understanding of the similarities and differences among the sensors in our study.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Transposing the &#39;air_fft&#39; DataFrame for time series clustering.</span>
</span></span><span style="display:flex;"><span>fft_transpose <span style="color:#f92672">=</span> air_fft<span style="color:#f92672">.</span>transpose()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initializing the Time Series K-Means model with 10 clusters, using the DTW (Dynamic Time Warping) metric, and setting a maximum of 5 iterations.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &#39;n_clusters&#39; specifies the number of clusters, &#39;max_iter&#39; sets the maximum number of iterations for the clustering process.</span>
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> TimeSeriesKMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dtw&#34;</span>, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>pre <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>fit(fft_transpose) <span style="color:#75715e"># Fitting the model to the transposed FFT data.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Creating a DataFrame &#39;df_cluster&#39; to map each metric in &#39;air_fft&#39; to its corresponding cluster label.</span>
</span></span><span style="display:flex;"><span>df_cluster <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(list(zip(air_fft<span style="color:#f92672">.</span>columns, pre<span style="color:#f92672">.</span>labels_)), columns<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;metric&#39;</span>, <span style="color:#e6db74">&#39;cluster&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cluster_metrics_dict <span style="color:#f92672">=</span> df_cluster<span style="color:#f92672">.</span>groupby([<span style="color:#e6db74">&#39;cluster&#39;</span>])[<span style="color:#e6db74">&#39;metric&#39;</span>]<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> x])<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_metrics_dict&#39; mapping each cluster to the metrics it contains.</span>
</span></span><span style="display:flex;"><span>cluster_len_dict <span style="color:#f92672">=</span> df_cluster[<span style="color:#e6db74">&#39;cluster&#39;</span>]<span style="color:#f92672">.</span>value_counts()<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_len_dict&#39; to count the number of metrics in each cluster.</span>
</span></span><span style="display:flex;"><span>clusters_dropped <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a list &#39;clusters_dropped&#39; containing clusters with only one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a sorted list &#39;clusters_final&#39; containing clusters with more than one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the first 10 rows of the &#39;df_cluster&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>print(df_cluster<span style="color:#f92672">.</span>head(<span style="color:#ae81ff">10</span>))
</span></span></code></pre></div><pre tabindex="0"><code>         metric  cluster
0  08BEAC07D3E2        7
1  08BEAC09FF22        3
2  08BEAC09FF2A        0
3  08BEAC09FF42        7
4  08BEAC09FF48        7
5  08BEAC09FF66        7
6  08BEAC09FF80        7
7  08BEAC09FF82        0
8  08BEAC09FF8C        2
9  08BEAC09FF9C        8
</code></pre><p>In the final stage of our analysis, we create individual plots for the sensor data of each of the nine remaining clusters. These plots will be based on the frequency-domain data we obtained after applying the Fast Fourier Transform (FFT).</p>
<p>By visually representing the data in this way, we can observe and compare the characteristics of the sensors within each cluster. What we expect to find is that the sensors grouped into the same cluster will display very similar patterns in the frequency domain. This similarity indicates that these sensors are responding to environmental factors in a similar way.</p>
<p>Conversely, when we compare the frequency-domain data of sensors from different clusters, we anticipate seeing more significant differences. This contrast highlights the distinct behaviors or responses of sensors in different environmental conditions or locations.</p>
<p>These plots are crucial for a comprehensive understanding of our data. They not only validate the effectiveness of our clustering approach but also provide valuable insights into the similarities and differences among the sensors, based on how they react to various environmental factors as reflected in their frequency-domain data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Creating a figure with a subplot for each cluster in &#39;clusters_final&#39;, setting specific size and resolution.</span>
</span></span><span style="display:flex;"><span>fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(nrows<span style="color:#f92672">=</span>len(clusters_final), ncols<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">15</span>), dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterating over each cluster in &#39;clusters_final&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, cluster_number <span style="color:#f92672">in</span> enumerate(clusters_final):
</span></span><span style="display:flex;"><span>  x_corr <span style="color:#f92672">=</span> air_fft[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>corr()<span style="color:#f92672">.</span>abs()<span style="color:#f92672">.</span>values <span style="color:#75715e"># Calculating the absolute correlation matrix for the metrics in the current cluster.</span>
</span></span><span style="display:flex;"><span>  x_corr_mean <span style="color:#f92672">=</span> round(x_corr[np<span style="color:#f92672">.</span>triu_indices(x_corr<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">1</span>)]<span style="color:#f92672">.</span>mean(),<span style="color:#ae81ff">2</span>) <span style="color:#75715e"># Calculating the mean of the upper triangle of the correlation matrix, rounding to two decimal places.</span>
</span></span><span style="display:flex;"><span>  plot_title <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;cluster </span><span style="color:#e6db74">{</span>cluster_number<span style="color:#e6db74">}</span><span style="color:#e6db74"> (quality=</span><span style="color:#e6db74">{</span>x_corr_mean<span style="color:#e6db74">}</span><span style="color:#e6db74">, n=</span><span style="color:#e6db74">{</span>cluster_len_dict[cluster_number]<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#39;</span> <span style="color:#75715e"># Creating a title for the subplot with cluster number, quality (mean correlation), and number of metrics.</span>
</span></span><span style="display:flex;"><span>  air_fft[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>plot(ax<span style="color:#f92672">=</span>axes[idx], title<span style="color:#f92672">=</span>plot_title) <span style="color:#75715e"># Plotting the metrics in the current cluster on the respective subplot.</span>
</span></span><span style="display:flex;"><span>  axes[idx]<span style="color:#f92672">.</span>get_legend()<span style="color:#f92672">.</span>remove() <span style="color:#75715e"># Removing the legend from each subplot for clarity.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig<span style="color:#f92672">.</span>tight_layout() <span style="color:#75715e"># Adjusting the layout for better visibility and aesthetics.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show() <span style="color:#75715e"># Displaying the complete figure.</span>
</span></span></code></pre></div><p><img src="figures/4-3-4-4.png" alt="Python output"></p>
<p>The wavelet transform is another valuable method for analyzing data, complementing the Fourier transform. While the Fourier transform converts time-domain data to the frequency domain, the wavelet transform offers additional perspectives on this frequency-domain data. Its ability to provide more detailed insights makes the wavelet transform particularly useful for analyzing complex data types such as video, audio, and time series.</p>
<p>For performing wavelet transforms, we utilize the <code>pywt</code> package, a Python library designed for this purpose. The key to wavelet transform is the use of a &ldquo;mother wavelet&rdquo;  a kind of base function that helps in extracting features from time series data.</p>
<p>Before we proceed with the transformation, we need to identify which mother wavelet is most suitable for our data. In <code>pywt</code>, there are various mother wavelets available, each with unique characteristics that make them suited for different types of data. To find out which mother wavelets we can use, we&rsquo;ll start with the following syntax in Python, which lists the names of all available mother wavelets in the <code>pywt</code> package. This step is crucial as the choice of mother wavelet can significantly impact the quality and relevance of our analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Using PyWavelets to get a list of all available continuous wavelets.</span>
</span></span><span style="display:flex;"><span>wavlist <span style="color:#f92672">=</span> pywt<span style="color:#f92672">.</span>wavelist(kind<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;continuous&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the list of continuous wavelets.</span>
</span></span><span style="display:flex;"><span>print(wavlist)
</span></span></code></pre></div><pre tabindex="0"><code>[&#39;cgau1&#39;, &#39;cgau2&#39;, &#39;cgau3&#39;, &#39;cgau4&#39;, &#39;cgau5&#39;, &#39;cgau6&#39;, &#39;cgau7&#39;, &#39;cgau8&#39;, &#39;cmor&#39;, &#39;fbsp&#39;, &#39;gaus1&#39;, &#39;gaus2&#39;, &#39;gaus3&#39;, &#39;gaus4&#39;, &#39;gaus5&#39;, &#39;gaus6&#39;, &#39;gaus7&#39;, &#39;gaus8&#39;, &#39;mexh&#39;, &#39;morl&#39;, &#39;shan&#39;]
</code></pre><p>The wavelet transform offers a unique advantage over the Fourier transform. While the Fourier transform focuses solely on frequency changes, the wavelet transform can adjust, or &lsquo;scale,&rsquo; a finite mother wavelet to extract specific features from segments of data. This scaling ability allows for a more nuanced analysis of the data, particularly when dealing with non-stationary signals where frequency components vary over time.</p>
<p>An important part of using the wavelet transform is selecting the right mother wavelet for your data. Each mother wavelet has its own shape and properties, making some better suited for certain types of data than others. To make an informed choice, it&rsquo;s often helpful to visually inspect the wavelet.</p>
<p>For instance, if we consider using the &lsquo;morl&rsquo; (Morlet) mother wavelet, we can first draw its shape to understand its characteristics. The Morlet wavelet, known for its good balance between time and frequency localization, is often used in signal processing. To visualize the Morlet wavelet, we would use specific syntax in Python to create a graph that represents it. This visual representation helps in deciding whether the &lsquo;morl&rsquo; wavelet is the appropriate choice for our data analysis, allowing us to see how it might interact with the data&rsquo;s features.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Initializing the Morlet wavelet object.</span>
</span></span><span style="display:flex;"><span>wav <span style="color:#f92672">=</span> pywt<span style="color:#f92672">.</span>ContinuousWavelet(<span style="color:#e6db74">&#34;morl&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting the scale for the wavelet. In this case, it&#39;s set to 1, but can be adjusted as needed.</span>
</span></span><span style="display:flex;"><span>scale <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Integrating the wavelet function with a specified precision.</span>
</span></span><span style="display:flex;"><span>int_psi, x <span style="color:#f92672">=</span> pywt<span style="color:#f92672">.</span>integrate_wavelet(wav, precision<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Normalizing the integrated wavelet function so its absolute maximum value is 1.</span>
</span></span><span style="display:flex;"><span>int_psi <span style="color:#f92672">/=</span> np<span style="color:#f92672">.</span>abs(int_psi)<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reversing the wavelet filter to match the convention for convolution operations.</span>
</span></span><span style="display:flex;"><span>wav_filter <span style="color:#f92672">=</span> int_psi[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nt <span style="color:#f92672">=</span> len(wav_filter) <span style="color:#75715e"># Getting the number of time samples in the wavelet filter.</span>
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span>nt <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>, nt <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>, nt) <span style="color:#75715e"># Creating a time array for plotting.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(t, wav_filter<span style="color:#f92672">.</span>real) <span style="color:#75715e"># Plotting the real part of the wavelet filter against time.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim([<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]) <span style="color:#75715e"># Setting the y-axis limits to [-1, 1].</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;time (samples)&#34;</span>) <span style="color:#75715e"># Labeling the x-axis.</span>
</span></span></code></pre></div><p><img src="figures/4-3-4-5.png" alt="Python output"></p>
<p>To proceed with the wavelet transform using the &lsquo;morl&rsquo; (Morlet) mother wavelet, we start by setting up the necessary parameters. This includes specifying &lsquo;morl&rsquo; as our mother wavelet of choice.</p>
<p>For the sensor data we are focusing on, we need to determine the appropriate scale range for the Morlet wavelet. In this case, we decide to vary the scale from 1 to 31 times. This range allows us to observe how the wavelet, when scaled to different sizes, extracts features from the sensor data.</p>
<p>Once the parameters are set, we perform the wavelet transform on the selected sensor&rsquo;s data. This process involves applying the Morlet wavelet at each scale within our specified range and analyzing how the wavelet interacts with the data.</p>
<p>After the wavelet transformation is complete, we plot the results. These plots are crucial as they visually represent the outcome of the wavelet transform. They show us the different features the Morlet wavelet has extracted from the data at various scales. This kind of analysis is particularly useful for understanding complex time-series data, as it reveals both the frequency and time-related characteristics of the data, offering a more comprehensive view than what is possible with the Fourier transform alone.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Setting the sampling frequency to 1 sample per hour.</span>
</span></span><span style="display:flex;"><span>F <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>  <span style="color:#75715e"># Samples per hour</span>
</span></span><span style="display:flex;"><span>hours <span style="color:#f92672">=</span> <span style="color:#ae81ff">744</span> <span style="color:#75715e"># Specifying the total number of hours (for a month with 31 days).</span>
</span></span><span style="display:flex;"><span>nos <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>int(F<span style="color:#f92672">*</span>hours) <span style="color:#75715e"># Calculating the number of samples in 31 days.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> air_clean[<span style="color:#e6db74">&#39;08BEAC09FF2A&#39;</span>] <span style="color:#75715e"># Selecting the time series data from the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>scales <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># Setting the range of scales to use in the CWT.</span>
</span></span><span style="display:flex;"><span>coef, freqs <span style="color:#f92672">=</span> cwt(x, scales, <span style="color:#e6db74">&#39;morl&#39;</span>) <span style="color:#75715e"># Performing the Continuous Wavelet Transform using the Morlet wavelet.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Creating a figure for the scalogram.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Displaying the scalogram with specific settings for visualization.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>imshow(abs(coef), extent<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">744</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">1</span>], interpolation<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bilinear&#39;</span>, cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;viridis&#39;</span>,
</span></span><span style="display:flex;"><span>           aspect<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;auto&#39;</span>, vmax<span style="color:#f92672">=</span>abs(coef)<span style="color:#f92672">.</span>max(), vmin<span style="color:#f92672">=</span>abs(coef)<span style="color:#f92672">.</span>min())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Inverting the y-axis so that the scale increases upwards.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>gca()<span style="color:#f92672">.</span>invert_yaxis()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting the ticks for the y-axis (scales).</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>yticks(np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting the ticks for the x-axis (hours), dividing the month into 20 equal intervals.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xticks(np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">0</span>, nos<span style="color:#f92672">/</span>F, nos<span style="color:#f92672">/</span>(<span style="color:#ae81ff">20</span><span style="color:#f92672">*</span>F)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Labeling the y-axis as &#39;scales&#39; and the x-axis as &#39;hour&#39;.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;scales&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;hour&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Adding a colorbar to indicate the magnitude of the wavelet coefficients.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>colorbar()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Displaying the plot.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="figures/4-3-4-6.png" alt="Python output"></p>
<p>When we analyze the results of the wavelet transform, particularly with the Morlet wavelet (&lsquo;morl&rsquo;), we observe a distinct pattern in the visualization. The scale of the wavelet, which we varied from 1 to 31 times, is reflected in the color intensity of the plot. Generally, the larger the scale, the more the color tends toward yellow-green. This color change indicates a closer resemblance between the extracted features and the mother wavelet. In contrast, smaller scales, where the features are less similar to the mother wavelet, exhibit different color intensities.</p>
<p>This observation is key for understanding how different scales of the wavelet reveal different aspects of the data. The resemblance to the mother wavelet at various scales gives us insight into the frequency and time characteristics of the sensor data.</p>
<p>However, the wavelet transform converts each site&rsquo;s data into two-dimensional feature values. To prepare this data for clustering, we need to reformat it from two dimensions into one dimension. This step is crucial for the upcoming data grouping process. We will consolidate the transformed data fields into a single-dimensional format and store them in a variable named <code>air_cwt</code>.</p>
<p>By converting the two-dimensional wavelet transform results into a one-dimensional format, we make the data compatible with clustering algorithms like <code>TimeSeriesKMeans</code>. This process ensures that the rich, multi-scale information extracted by the wavelet transform is effectively utilized in our subsequent data grouping analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>air_cwt <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame() <span style="color:#75715e"># Initializing an empty DataFrame to store the CWT results.</span>
</span></span><span style="display:flex;"><span>scales <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">2</span>) <span style="color:#75715e"># Setting the range of scales for the CWT.</span>
</span></span><span style="display:flex;"><span>col_names <span style="color:#f92672">=</span> list(air_clean<span style="color:#f92672">.</span>columns) <span style="color:#75715e"># Extracting the column names from the &#39;air_clean&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Looping through each column in &#39;air_clean&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> name <span style="color:#f92672">in</span> col_names:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Performing the Continuous Wavelet Transform using the Morlet wavelet.</span>
</span></span><span style="display:flex;"><span>  coef, freqs <span style="color:#f92672">=</span> cwt(air_clean[name], scales, <span style="color:#e6db74">&#39;morl&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Reshaping the coefficients into a one-dimensional array and storing their absolute values in &#39;air_cwt&#39;.</span>
</span></span><span style="display:flex;"><span>  air_cwt[name] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>abs(coef<span style="color:#f92672">.</span>reshape(coef<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>coef<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the first five rows of the &#39;air_cwt&#39; DataFrame to verify the results.</span>
</span></span><span style="display:flex;"><span>print(air_cwt<span style="color:#f92672">.</span>head())
</span></span></code></pre></div><pre tabindex="0"><code>08BEAC07D3E2  08BEAC09FF22  08BEAC09FF2A  08BEAC09FF42  08BEAC09FF48  \
0      0.778745      6.336664      2.137342      1.849035      0.778745   
1      0.929951      8.348031      2.977576      1.829540      0.958915   
2      1.190476     11.476048      3.223773      1.832544      1.292037   
3      1.227021     12.890554      4.488244      1.634717      1.338655   
4      1.252126     14.103178      5.715656      1.430744      1.376562   

   08BEAC09FF66  08BEAC09FF80  08BEAC09FF82  08BEAC09FF8C  08BEAC09FF9C  ...  \
0      0.555941      0.334225      8.110581      2.287378      0.409913  ...   
1      0.596532      0.201897      8.774271      1.706411      0.311242  ...   
2      0.771641      0.294242      8.327808      1.018296      2.754100  ...   
3      0.713931      0.065011      8.669036      0.249029      3.278048  ...   
4      0.670639      0.193083      8.795376      0.624988      3.628597  ...   

   74DA38F7C504  74DA38F7C514  74DA38F7C524  74DA38F7C554  74DA38F7C5BA  \
0      1.875873      1.090635      0.284901      1.111999      1.049112   
1      0.643478      1.446061      0.420701      0.974641      0.478931   
2      1.101801      2.404254      1.389941      1.190141      0.511454   
3      2.370436      2.510728      1.927692      0.703424      1.054164   
4      3.563873      2.387982      2.463458      0.098485      1.448078   

   74DA38F7C5BC  74DA38F7C5E0  74DA38F7C60C  74DA38F7C62A  74DA38F7C648  
0      1.107551      0.000918      0.080841      0.859855      0.415574  
1      0.245802      0.005389      1.053260      1.762642      0.190458  
2      1.162331      0.009754      2.667145      3.210326      0.516525  
3      1.993138      0.014496      3.669712      3.889207      0.666492  
4      2.672666      0.020433      4.482730      4.311888      0.677992  

[5 rows x 398 columns]
</code></pre><p>In transforming the two-dimensional wavelet transform results into a one-dimensional format, a significant increase occurs in the number of characteristic values (features) for each piece of data. This expansion adds complexity to the calculations we need to perform in the subsequent steps of our analysis. To manage this complexity and ensure efficient processing, we adopt a strategy of simplification: we select only the top 100 characteristic values to represent each sensor&rsquo;s data.</p>
<p>This selection of the top 100 features is a balancing act. It reduces computational demands while still retaining the most critical information extracted by the wavelet transform. With this simplified dataset, we then apply the KMeans method for data clustering.</p>
<p>Given that the wavelet transform can uncover more nuanced features in the data, we set an initial goal of forming 20 clusters in this data clustering phase. This number is a starting point, and we encourage readers to experiment with different numbers of clusters to see how it affects the results. Such experimentation can offer insights into the data&rsquo;s structure and the clustering algorithm&rsquo;s behavior.</p>
<p>As we proceed with the clustering, it&rsquo;s also essential to monitor the composition of these clusters. Specifically, we look for and eliminate any small clusters that contain only a single sensor. This step is crucial because a few sensors with unusual conditions could skew the overall results of our data grouping. By removing these outlier clusters, we aim to achieve a more accurate and representative clustering outcome, focusing on broader trends and patterns in the data rather than exceptions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>air_cwt_less <span style="color:#f92672">=</span> air_cwt<span style="color:#f92672">.</span>iloc[:, <span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">101</span>] <span style="color:#75715e"># Selecting the first 101 columns from the &#39;air_cwt&#39; DataFrame for clustering.</span>
</span></span><span style="display:flex;"><span>cwt_transpose <span style="color:#f92672">=</span> air_cwt_less<span style="color:#f92672">.</span>transpose() <span style="color:#75715e"># Transposing the reduced &#39;air_cwt&#39; DataFrame for time series clustering.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initializing the Time Series K-Means model with 20 clusters, using the DTW (Dynamic Time Warping) metric, </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># setting a maximum of 10 iterations, enabling verbose output, and using all available CPU cores.</span>
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> TimeSeriesKMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dtw&#34;</span>, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, verbose<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, n_jobs<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pre <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>fit(cwt_transpose) <span style="color:#75715e"># Fitting the model to the transposed CWT data.</span>
</span></span><span style="display:flex;"><span>df_cluster <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(list(zip(air_cwt<span style="color:#f92672">.</span>columns, pre<span style="color:#f92672">.</span>labels_)), columns<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;metric&#39;</span>, <span style="color:#e6db74">&#39;cluster&#39;</span>]) <span style="color:#75715e"># Creating a DataFrame &#39;df_cluster&#39; to map each metric in &#39;air_cwt&#39; to its corresponding cluster label.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cluster_metrics_dict <span style="color:#f92672">=</span> df_cluster<span style="color:#f92672">.</span>groupby([<span style="color:#e6db74">&#39;cluster&#39;</span>])[<span style="color:#e6db74">&#39;metric&#39;</span>]<span style="color:#f92672">.</span>apply(<span style="color:#66d9ef">lambda</span> x: [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> x])<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_metrics_dict&#39; mapping each cluster to the metrics it contains.</span>
</span></span><span style="display:flex;"><span>cluster_len_dict <span style="color:#f92672">=</span> df_cluster[<span style="color:#e6db74">&#39;cluster&#39;</span>]<span style="color:#f92672">.</span>value_counts()<span style="color:#f92672">.</span>to_dict() <span style="color:#75715e"># Creating a dictionary &#39;cluster_len_dict&#39; to count the number of metrics in each cluster.</span>
</span></span><span style="display:flex;"><span>clusters_dropped <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a list &#39;clusters_dropped&#39; containing clusters with only one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final <span style="color:#f92672">=</span> [cluster <span style="color:#66d9ef">for</span> cluster <span style="color:#f92672">in</span> cluster_len_dict <span style="color:#66d9ef">if</span> cluster_len_dict[cluster]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e"># Creating a sorted list &#39;clusters_final&#39; containing clusters with more than one metric.</span>
</span></span><span style="display:flex;"><span>clusters_final<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Printing the first 10 rows of the &#39;df_cluster&#39; DataFrame.</span>
</span></span><span style="display:flex;"><span>print(df_cluster<span style="color:#f92672">.</span>head(<span style="color:#ae81ff">10</span>))
</span></span></code></pre></div><pre tabindex="0"><code>metric  cluster
0  08BEAC07D3E2        7
1  08BEAC09FF22        3
2  08BEAC09FF2A        6
3  08BEAC09FF42       10
4  08BEAC09FF48        7
5  08BEAC09FF66        7
6  08BEAC09FF80        7
7  08BEAC09FF82        6
8  08BEAC09FF8C       15
9  08BEAC09FF9C       19
</code></pre><p>In our example, following the process of selecting the top 100 characteristic values and applying the KMeans method to the wavelet-transformed data, we end up with 14 distinct clusters. This is after we&rsquo;ve removed any clusters that consisted of only a single sensor, as these are considered outliers and not representative of general trends.</p>
<p>The next step is to visually represent the raw sensor data for each of these 14 clusters. This visualization is crucial as it allows us to observe the consistency within each cluster and the distinctions between different clusters. When we plot the raw data of the sensors in each cluster, we notice a clear pattern: the data within the same cluster show a high degree of similarity.</p>
<p>Moreover, the differences between clusters are more pronounced and detailed compared to the results we obtained using either the raw data or the Fourier transform. This indicates that the wavelet transform, combined with our clustering approach, provides a more nuanced understanding of the data. It captures subtler features and patterns that might be missed with other methods.</p>
<p>These findings underscore the effectiveness of the wavelet transform in extracting intricate features from time-series data. The resulting clusters reveal a more refined and detailed grouping of the sensors, offering deeper insights into the underlying dynamics and characteristics of the environmental data we are analyzing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Creating a figure with a subplot for each cluster in &#39;clusters_final&#39;, setting specific size and resolution.</span>
</span></span><span style="display:flex;"><span>fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(nrows<span style="color:#f92672">=</span>len(clusters_final), ncols<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">15</span>), dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterating over each cluster in &#39;clusters_final&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, cluster_number <span style="color:#f92672">in</span> enumerate(clusters_final):
</span></span><span style="display:flex;"><span>  x_corr <span style="color:#f92672">=</span> air_cwt[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>corr()<span style="color:#f92672">.</span>abs()<span style="color:#f92672">.</span>values <span style="color:#75715e"># Calculating the absolute correlation matrix for the metrics in the current cluster.</span>
</span></span><span style="display:flex;"><span>  x_corr_mean <span style="color:#f92672">=</span> round(x_corr[np<span style="color:#f92672">.</span>triu_indices(x_corr<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">1</span>)]<span style="color:#f92672">.</span>mean(),<span style="color:#ae81ff">2</span>) <span style="color:#75715e"># Calculating the mean of the upper triangle of the correlation matrix, rounding to two decimal places.</span>
</span></span><span style="display:flex;"><span>  plot_title <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;cluster </span><span style="color:#e6db74">{</span>cluster_number<span style="color:#e6db74">}</span><span style="color:#e6db74"> (quality=</span><span style="color:#e6db74">{</span>x_corr_mean<span style="color:#e6db74">}</span><span style="color:#e6db74">, n=</span><span style="color:#e6db74">{</span>cluster_len_dict[cluster_number]<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#39;</span> <span style="color:#75715e"># Creating a title for the subplot with cluster number, quality (mean correlation), and number of metrics.</span>
</span></span><span style="display:flex;"><span>  air_cwt[cluster_metrics_dict[cluster_number]]<span style="color:#f92672">.</span>plot(ax<span style="color:#f92672">=</span>axes[idx], title<span style="color:#f92672">=</span>plot_title) <span style="color:#75715e"># Plotting the metrics in the current cluster on the respective subplot.</span>
</span></span><span style="display:flex;"><span>  axes[idx]<span style="color:#f92672">.</span>get_legend()<span style="color:#f92672">.</span>remove() <span style="color:#75715e"># Removing the legend from each subplot for clarity.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Adjusting the layout for better visibility and aesthetics.</span>
</span></span><span style="display:flex;"><span>fig<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Displaying the complete figure.</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="figures/4-3-4-7.png" alt="Python output"></p>
<h2 id="references">References</h2>
<ul>
<li>Civil IoT Taiwan: Historical Data (<a href="https://history.colife.org.tw/#/">https://history.colife.org.tw/</a>)</li>
<li>Time Series Clustering  Deriving Trends and Archetypes from Sequential Data | by Denyse | Towards Data Science (<a href="https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3">https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3</a>)</li>
<li>How to Apply K-means Clustering to Time Series Data | by Alexandra Amidon | Towards Data Science (<a href="https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3">https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3</a>)</li>
<li>Understanding K-means Clustering: Hands-On with SciKit-Learn | by Carla Martins | May, 2022 | Towards AI (<a href="https://pub.towardsai.net/understanding-k-means-clustering-hands-on-with-scikit-learn-b522c0698c81">https://pub.towardsai.net/understanding-k-means-clustering-hands-on-with-scikit-learn-b522c0698c81</a>)</li>
<li>Fast Fourier Transform. How to implement the Fast Fourier | by Cory Maklin | Towards Data Science (<a href="https://towardsdatascience.com/fast-fourier-transform-937926e591cb">https://towardsdatascience.com/fast-fourier-transform-937926e591cb</a>)</li>
<li>PyWavelets/pywt: PyWavelets - Wavelet Transforms in Python (<a href="https://github.com/PyWavelets/pywt">https://github.com/PyWavelets/pywt</a>)</li>
</ul>

            <footer class="footline">
            </footer>
          </article>


<div align="center">
<hr width="70%">

This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 Unported License</a>.
<br />
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0;margin:2px" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
</div>
<p style="height:30px">

<div id="disqus_thread" style="border-style: ridge; padding-inline:5px"></div>
<script type="text/javascript">

(function() {
    
    
    
    

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'learnciot';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
      </main>
    </div>
    <aside id="sidebar" class="default-animation showVisitedLinks">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">
          <style>
            #logo svg,
            #logo svg * {
              color: #282828;
              color: var(--MENU-SECTIONS-BG-color);
              fill: #282828 !important;
              fill: var(--MENU-SECTIONS-BG-color) !important;
              opacity: .945;
            }
            a#logo {
              color: #282828;
              color: var(--MENU-SECTIONS-BG-color);
              font-family: 'Work Sans', 'Helvetica', 'Tahoma', 'Geneva', 'Arial', sans-serif;
              font-size: 30px;
              font-weight: 300;
              margin-top: -13px;
              max-width: 60%;
              text-transform: uppercase;
              width: 226px;
              white-space: nowrap;
            }
            a#logo:hover {
              color: #282828;
              color: var(--MENU-SECTIONS-BG-color);
            }
            #logo svg {
              margin-bottom: -20px;
              margin-left: -23.5px;
              width: 40.5%;
            }
            @media only all and (max-width: 59.938em) {
              a#logo {
                font-size: 25px;
                margin-top: -3px;
              }
              #logo svg {
                margin-bottom: -12px;
                margin-left: -23px;
              }
            }
            @media all and (-ms-high-contrast:none) {
              /* IE11s understanding of positioning is weird at best */
              a#logo {
                margin-top: -58px;
              }
              #logo svg {
                margin-bottom: -62px;
              }
            }
          </style>
          <a id="logo" href="/en/">
            Learn CIoT
          </a>

        </div>
        <div class="searchbox default-animation">
          <label class="a11y-only" for="search-by">Search</label>
          <i class="fas fa-search"></i>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="/js/auto-complete.js?1701306708" defer></script>
        <script src="/js/lunr.min.js?1701306708" defer></script>
        <script src="/js/lunr.stemmer.support.min.js?1701306708" defer></script>
        <script src="/js/lunr.multi.min.js?1701306708" defer></script>
        <script src="/js/lunr.en.min.js?1701306708" defer></script>
        <script src="/js/search.js?1701306708" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics">
          <li data-nav-id="/en/ch1/" title="1. Introduction" class="dd-item"><a href="/en/ch1/">1. Introduction<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch2/" title="2. Overview of the Materials" class="dd-item"><label for="section-8824f0908e4fd15c767980c76e6fd82a" ></label><a href="/en/ch2/">2. Overview of the Materials<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch2/ch2.1/" title="2.1. Material Architecture" class="dd-item"><a href="/en/ch2/ch2.1/">2.1. Material Architecture<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch2/ch2.2/" title="2.2. Material Tools" class="dd-item"><a href="/en/ch2/ch2.2/">2.2. Material Tools<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/ch3/" title="3. Data Access" class="dd-item"><label for="section-8b3bcaa38467a39b2570f38fd8603d10" ></label><a href="/en/ch3/">3. Data Access<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch3/ch3.1/" title="3.1. Basic Data Access Methods" class="dd-item"><a href="/en/ch3/ch3.1/">3.1. Basic Data Access Methods<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch3/ch3.2/" title="3.2. Data Access under Spatial or Temporal Conditions" class="dd-item"><a href="/en/ch3/ch3.2/">3.2. Data Access under Spatial or Temporal Conditions<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/ch4/" title="4. Time Series Data Analysis" class="dd-item parent"><label for="section-b911da0d9c15f301a7d3deea0e716021" ></label><a href="/en/ch4/">4. Time Series Data Analysis<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch4/ch4.1/" title="4.1. Time Series Data Processing" class="dd-item"><a href="/en/ch4/ch4.1/">4.1. Time Series Data Processing<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch4/ch4.2/" title="4.2. Time Series Data Forecast" class="dd-item"><a href="/en/ch4/ch4.2/">4.2. Time Series Data Forecast<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch4/ch4.3/" title="4.3. Time Series Data Clustering" class="dd-item active"><a href="/en/ch4/ch4.3/">4.3. Time Series Data Clustering<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/ch5/" title="5. Spatial Data Analysis" class="dd-item"><label for="section-adab050366c685297e1eadc5faf1472e" ></label><a href="/en/ch5/">5. Spatial Data Analysis<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch5/ch5.1/" title="5.1. Geospatial Filtering" class="dd-item"><a href="/en/ch5/ch5.1/">5.1. Geospatial Filtering<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch5/ch5.2/" title="5.2. Geospatial Analysis" class="dd-item"><a href="/en/ch5/ch5.2/">5.2. Geospatial Analysis<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/ch6/" title="6. Data Applications" class="dd-item"><label for="section-4be7f7872a5d83dfd50bf0f4ff5c2761" ></label><a href="/en/ch6/">6. Data Applications<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch6/ch6.1/" title="6.1. Machine Learning Preliminaries" class="dd-item"><a href="/en/ch6/ch6.1/">6.1. Machine Learning Preliminaries<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch6/ch6.2/" title="6.2. Anomaly Detection" class="dd-item"><a href="/en/ch6/ch6.2/">6.2. Anomaly Detection<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch6/ch6.3/" title="6.3. Joint Data Calibration" class="dd-item"><a href="/en/ch6/ch6.3/">6.3. Joint Data Calibration<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/ch7/" title="7. System Applications" class="dd-item"><label for="section-af7207ef140cc843a4d69557766c672f" ></label><a href="/en/ch7/">7. System Applications<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/en/ch7/ch7.1/" title="7.1. QGIS Application" class="dd-item"><a href="/en/ch7/ch7.1/">7.1. QGIS Application<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch7/ch7.2/" title="7.2. Tableau Application" class="dd-item"><a href="/en/ch7/ch7.2/">7.2. Tableau Application<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/en/ch7/ch7.3/" title="7.3. Leafmap Applications" class="dd-item"><a href="/en/ch7/ch7.3/">7.3. Leafmap Applications<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/en/about/" title="About" class="dd-item"><a href="/en/about/">About<i class="fas fa-check read-icon"></i></a></li>
        </ul>
        <div id="shortcuts">
          <div class="nav-title">More</div>
          <ul>
            <li><a class="padding" href="https://github.com/LearnCIOT/LearnCIOT.github.io"><i class='fab fa-fw fa-github'></i> GitHub repo</a></li>
            <li><a class="padding" href="/en/levels/"><i class='fas fa-fw fa-heartbeat'></i> Search by difficulty</a></li>
            <li><a class="padding" href="/en/tags/"><i class='fas fa-fw fa-tags'></i> Search by topics</a></li>
            <li><a class="padding" href="/en/authors/"><i class='fas fa-fw fa-users'></i> Search by authors</a></li>
          </ul>
        </div>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showLangSwitch showVisitedLinks showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showLangSwitch showVisitedLinks showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showLangSwitch showVisitedLinks">
          <ul>
            <li id="select-language-container" class="footerLangSwitch showLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                    <option id="en" value="/en/ch4/ch4.3/" selected>English</option>
                    <option id="zh-tw" value="/ch4/ch4.3/"></option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                    <option id="relearn-light" value="relearn-light" selected>Relearn Light</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>window.variants && variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks showVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter">
	    <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
        </div>
      </div>
    </aside>

    <script src="/js/clipboard.min.js?1701306708" defer></script>
    <script src="/js/perfect-scrollbar.min.js?1701306708" defer></script>
    <script src="/js/featherlight.min.js?1701306708" defer></script>
    <script src="/js/jquery.svg.pan.zoom.js?1701306708" defer></script>
    <script src="/js/mermaid.min.js?1701306708" defer></script>
    <script>
      window.themeUseMermaid = JSON.parse("{}");
    </script>
    <script src="/js/theme.js?1701306708" defer></script>
  </body>
</html>
